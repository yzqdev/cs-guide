import{_ as a,c as t,a as o,o as s}from"./app-B6vXTniy.js";const n={};function h(r,e){return s(),t("div",null,[...e[0]||(e[0]=[o('<h1 id="hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable的区别"><span>HashMap和Hashtable的区别</span></a></h1><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h3><p>在Java中<code>HashMap</code>和<code>Hashtable</code>的区别？ 哪一个对于多线程应用程序更好？</p><h3 id="回答" tabindex="-1"><a class="header-anchor" href="#回答"><span>回答</span></a></h3><ol><li><code>Hashtable</code>是同步的，加了<code>synchronized</code>锁，而<code>HashMap</code>不是。没有加<code>synchronized</code>锁的对象，性能通常比加了<code>synchronized</code>锁的对象要更好一些，因此，如果是非多线程程序，不需要考虑锁、同步等问题，那么使用<code>HashMap</code>更好。</li><li><code>Hashtable</code>不允许有空的键或值。<code>HashMap</code>允许空键和空值。</li><li>HashMap有一个子类<a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener noreferrer">LinkedHashMap</a>,对这个类对象进行迭代时，它的顺序是有序的（按插入顺序排序）。如有需要，你也能轻易的从<code>LinkedHashMap</code>转化成<code>HashMap</code>。<code>Hashtable</code>就没那么简单了，</li></ol><p>总之，如果你无需关心同步（synchronized）问题，我会建议用<code>HashMap</code>。反之，你可以考虑使用<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener noreferrer">ConcurrentHashMap</a></p><p><a href="http://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable" target="_blank" rel="noopener noreferrer">http://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable</a></p><h3 id="相关推荐" tabindex="-1"><a class="header-anchor" href="#相关推荐"><span>相关推荐</span></a></h3><p>importnew:<a href="http://www.importnew.com/7010.html" target="_blank" rel="noopener noreferrer">HashMap和Hashtable的区别</a></p>',9)])])}const p=a(n,[["render",h]]),d=JSON.parse('{"path":"/cs-tips/java-tip/stackoverflow/differences-between-hashmap-and-hashtable.html","title":"HashMap和Hashtable的区别","lang":"zh-CN","frontmatter":{"description":"HashMap和Hashtable的区别 问题 在Java中HashMap和Hashtable的区别？ 哪一个对于多线程应用程序更好？ 回答 Hashtable是同步的，加了synchronized锁，而HashMap不是。没有加synchronized锁的对象，性能通常比加了synchronized锁的对象要更好一些，因此，如果是非多线程程序，不需要...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap和Hashtable的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-25T04:34:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yzqdev\\",\\"url\\":\\"http://www.yzqdev.top\\"}]}"],["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/cs-tips/java-tip/stackoverflow/differences-between-hashmap-and-hashtable.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"HashMap和Hashtable的区别"}],["meta",{"property":"og:description","content":"HashMap和Hashtable的区别 问题 在Java中HashMap和Hashtable的区别？ 哪一个对于多线程应用程序更好？ 回答 Hashtable是同步的，加了synchronized锁，而HashMap不是。没有加synchronized锁的对象，性能通常比加了synchronized锁的对象要更好一些，因此，如果是非多线程程序，不需要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-25T04:34:06.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-25T04:34:06.000Z"}]]},"git":{"createdTime":1684989246000,"updatedTime":1684989246000,"contributors":[{"name":"yzqdev","username":"yzqdev","email":"yzqdev@outlook.com","commits":1,"url":"https://github.com/yzqdev"}]},"readingTime":{"minutes":0.77,"words":231},"filePathRelative":"cs-tips/java-tip/stackoverflow/differences-between-hashmap-and-hashtable.md","autoDesc":true}');export{p as comp,d as data};
