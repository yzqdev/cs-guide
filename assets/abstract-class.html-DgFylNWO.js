import{_ as n,c as a,a as p,o as e}from"./app-B6vXTniy.js";const t={};function l(c,s){return e(),a("div",null,[...s[0]||(s[0]=[p(`<h1 id="java抽象类" tabindex="-1"><a class="header-anchor" href="#java抽象类"><span>java抽象类</span></a></h1><p>我们从我们实际设计场景中来切入这个话题</p><p>先来举一个简单的例子：</p><p>狗都具有 eat() 、sleep() 方法，我们分别通过抽象类和接口定义这个抽象概念</p><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line">  <span class="token comment">//通过抽象类定义</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//通过接口定义</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><p>但是我们现在如果需要让狗拥有一项特殊的技能——钻火圈 DrillFireCircle()，如何增加这个行为呢？</p><p>思考：</p><ol><li>将钻火圈方法与前面两个方法一同写入抽象类中，但是这样的话，但凡继承这个抽象类狗都具有了钻火圈技能，明显不合适</li><li>将钻火圈方法与前面两个方法一同写入接口中，当需要使用钻火圈功能的时候，就必须实现 接口中的eat() 、sleep() 方法（重写该接口中所有的方法）显然也不合适</li></ol><p>那么该如何解决呢 ? 我们可以仔细想一想,eat和sleep都是狗本身所应该具有的一种行为,而钻火圈这种行为则是后天训练出来的,只能算是对狗类的一种附加或者延伸, 两者不应该在同一个范畴内,所以我们考虑将这个单独的行为,独立的设计一个接口,其中包含DrillFireCircle()方法, Dog设计为一个抽象类, 其中又包括eat() 、sleep() 方法.</p><p>一个SpecialDog即可继承Dog类并且实现DrillFireCircle()接口</p><p>下面给出代码:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line">  <span class="token comment">//定义接口，含有钻火圈方法</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DrillFireCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">drillFireCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//定义抽象类狗类</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">   </span>
<span class="line">  <span class="token comment">//继承抽象类且实现接口</span></span>
<span class="line">  <span class="token keyword">class</span> <span class="token class-name">SpecialDog</span> <span class="token keyword">extends</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> drillFireCircle <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">//....</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">//....</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drillFireCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">//....</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结：</strong></span></a></h2><p>继承是一个 &quot;是不是&quot;的关系，而 接口 实现则是 &quot;有没有&quot;的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如狗是否能钻火圈，能则可以实现这个接口，不能就不实现这个接口。</p>`,14)])])}const i=n(t,[["render",l]]),r=JSON.parse('{"path":"/java-tutor/java-tips/abstract-class.html","title":"java抽象类","lang":"zh-CN","frontmatter":{"description":"java抽象类 我们从我们实际设计场景中来切入这个话题 先来举一个简单的例子： 狗都具有 eat() 、sleep() 方法，我们分别通过抽象类和接口定义这个抽象概念 但是我们现在如果需要让狗拥有一项特殊的技能——钻火圈 DrillFireCircle()，如何增加这个行为呢？ 思考： 将钻火圈方法与前面两个方法一同写入抽象类中，但是这样的话，但凡继承...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java抽象类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-04-05T15:17:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yzqdev\\",\\"url\\":\\"http://www.yzqdev.top\\"}]}"],["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/java-tutor/java-tips/abstract-class.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"java抽象类"}],["meta",{"property":"og:description","content":"java抽象类 我们从我们实际设计场景中来切入这个话题 先来举一个简单的例子： 狗都具有 eat() 、sleep() 方法，我们分别通过抽象类和接口定义这个抽象概念 但是我们现在如果需要让狗拥有一项特殊的技能——钻火圈 DrillFireCircle()，如何增加这个行为呢？ 思考： 将钻火圈方法与前面两个方法一同写入抽象类中，但是这样的话，但凡继承..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-04-05T15:17:32.000Z"}],["meta",{"property":"article:modified_time","content":"2022-04-05T15:17:32.000Z"}]]},"git":{"createdTime":1647861419000,"updatedTime":1649171852000,"contributors":[{"name":"yzqdev","username":"yzqdev","email":"yzqdev@outlook.com","commits":2,"url":"https://github.com/yzqdev"}]},"readingTime":{"minutes":1.9,"words":570},"filePathRelative":"java-tutor/java-tips/abstract-class.md","autoDesc":true}');export{i as comp,r as data};
