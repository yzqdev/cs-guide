import{_ as i,c as t,a as l,o as a}from"./app-B6vXTniy.js";const n={};function o(r,e){return a(),t("div",null,[...e[0]||(e[0]=[l(`<h1 id="gdb-调试利器" tabindex="-1"><a class="header-anchor" href="#gdb-调试利器"><span>gdb 调试利器</span></a></h1><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p><h2 id="启动gdb" tabindex="-1"><a class="header-anchor" href="#启动gdb"><span>启动gdb</span></a></h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p><pre><code>$g++ -g hello.cpp -o hello
</code></pre><p>调试可执行文件:</p><pre><code>$gdb &lt;program&gt;
</code></pre><p>program也就是你的执行文件，一般在当前目录下。</p><p>调试core文件(core是程序非法执行后core dump后产生的文件):</p><pre><code>$gdb &lt;program&gt; &lt;core dump file&gt;
$gdb program core.11127
</code></pre><p>调试服务程序:</p><pre><code>$gdb &lt;program&gt; &lt;PID&gt;
$gdb hello 11127
</code></pre><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p><h2 id="gdb交互命令" tabindex="-1"><a class="header-anchor" href="#gdb交互命令"><span>gdb交互命令</span></a></h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p><h3 id="运行" tabindex="-1"><a class="header-anchor" href="#运行"><span>运行</span></a></h3><ul><li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递&quot;参数&quot;，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点" tabindex="-1"><a class="header-anchor" href="#设置断点"><span>设置断点</span></a></h3><ul><li></li></ul><pre><code>break n （简写b n）:在第n行处设置断点

:   （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）
</code></pre><ul><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p></li><li><p>delete 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p>clear 行号n：清除第n行的断点</p></li><li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点：</p></li></ul><h3 id="查看源代码" tabindex="-1"><a class="header-anchor" href="#查看源代码"><span>查看源代码</span></a></h3><ul><li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以&quot;行号&quot;为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示&quot;函数名&quot;所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h3 id="打印表达式" tabindex="-1"><a class="header-anchor" href="#打印表达式"><span>打印表达式</span></a></h3><ul><li>print 表达式：简记为 p ，其中&quot;表达式&quot;可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么&quot;表达式&quot;可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的&quot;表达式&quot;的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息" tabindex="-1"><a class="header-anchor" href="#查询运行信息"><span>查询运行信息</span></a></h3><ul><li>where/bt ：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口" tabindex="-1"><a class="header-anchor" href="#分割窗口"><span>分割窗口</span></a></h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><div class="hint-container note"><p class="hint-container-title">注</p><p>::: title Note</p></div><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便； :::</p><h2 id="更强大的工具" tabindex="-1"><a class="header-anchor" href="#更强大的工具"><span>更强大的工具</span></a></h2><h3 id="cgdb" tabindex="-1"><a class="header-anchor" href="#cgdb"><span>cgdb</span></a></h3><p>cgdb可以看作gdb的界面增强版,用来替代gdb的 gdb -tui。cgdb主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。界面类似vi，符合unix/linux下开发人员习惯;如果熟悉gdb和vi，几乎可以立即使用cgdb。</p>`,34)])])}const d=i(n,[["render",o]]),c=JSON.parse('{"path":"/linux-tutor/tool/gdb.html","title":"gdb 调试利器","lang":"zh-CN","frontmatter":{"description":"gdb 调试利器 GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具； 启动gdb 对C/C++程序的调试，需要在编译前就加上-g选项: 调试可执行文件: program也就是你的执行文件，一般在当前目录下。 调试core文件(co...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"gdb 调试利器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-05-27T01:37:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yzqdev\\",\\"url\\":\\"http://www.yzqdev.top\\"}]}"],["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/linux-tutor/tool/gdb.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"gdb 调试利器"}],["meta",{"property":"og:description","content":"gdb 调试利器 GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具； 启动gdb 对C/C++程序的调试，需要在编译前就加上-g选项: 调试可执行文件: program也就是你的执行文件，一般在当前目录下。 调试core文件(co..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-05-27T01:37:35.000Z"}],["meta",{"property":"article:modified_time","content":"2022-05-27T01:37:35.000Z"}]]},"git":{"createdTime":1653565176000,"updatedTime":1653615455000,"contributors":[{"name":"yzqdev","username":"yzqdev","email":"yzqdev@outlook.com","commits":2,"url":"https://github.com/yzqdev"}]},"readingTime":{"minutes":4.64,"words":1391},"filePathRelative":"linux-tutor/tool/gdb.md","autoDesc":true}');export{d as comp,c as data};
