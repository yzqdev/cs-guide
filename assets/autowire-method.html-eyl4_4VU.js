import{_ as a,c as s,a as e,o as p}from"./app-B6vXTniy.js";const t={};function o(l,n){return p(),s("div",null,[...n[0]||(n[0]=[e(`<h1 id="注入方式" tabindex="-1"><a class="header-anchor" href="#注入方式"><span>注入方式</span></a></h1><h2 id="一、前言" tabindex="-1"><a class="header-anchor" href="#一、前言"><span>一、前言</span></a></h2><p>Spring框架对Java开发的重要性不言而喻，其核心特性就是IOC（Inversion of Control， 控制反转）和AOP，平时使用最多的就是其中的IOC，我们通过将组件交由Spring的IOC容器管理，将对象的依赖关系由Spring控制，避免硬编码所造成的过度程序耦合。前几天的时候，笔者的同事问我为什么要使用构造器的注入方式，我回答说因为Spring文档推荐这种，而说不出为什么 T^T，后面抽时间了解了一下，下面就是笔者要讨论的就是其注入方式。</p><h2 id="二、常见的三种注入方式" tabindex="-1"><a class="header-anchor" href="#二、常见的三种注入方式"><span>二、常见的三种注入方式</span></a></h2><h3 id="_2-1-field注入" tabindex="-1"><a class="header-anchor" href="#_2-1-field注入"><span>2.1 field注入</span></a></h3><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Controller</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooController</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">  <span class="token comment">//@Inject</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token class-name">FooService</span> fooService<span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//简单的使用例子，下同</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span> <span class="token function">listFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> fooService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><p>这种注入方式应该是笔者目前为止开发中见到的最常见的注入方式。原因很简单：</p><ol><li><p>注入方式非常简单：加入要注入的字段，附上<code>@Autowired</code>，即可完成。</p></li><li><p>使得整体代码简洁明了，看起来美观大方。</p></li></ol><h3 id="_2-2-构造器注入" tabindex="-1"><a class="header-anchor" href="#_2-2-构造器注入"><span>2.2 构造器注入</span></a></h3><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Controller</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooController</span> <span class="token punctuation">{</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FooService</span> fooService<span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token class-name">FooController</span><span class="token punctuation">(</span><span class="token class-name">FooService</span> fooService<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">this</span><span class="token punctuation">.</span>fooService <span class="token operator">=</span> fooService<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//使用方式上同，略</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><p>在Spring4.x版本中推荐的注入方式就是这种，相较于上面的field注入方式而言，就显得有点难看，特别是当注入的依赖很多（5个以上）的时候，就会明显的发现代码显得很臃肿。对于从field注入转过来+有强迫症的园友 来说，简直可以说是石乐志 (\`Д´*)9。对于这一点我们后面再来讨论，别急。</p><h3 id="_2-3-setter注入" tabindex="-1"><a class="header-anchor" href="#_2-3-setter注入"><span>2.3 setter注入</span></a></h3><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Controller</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooController</span> <span class="token punctuation">{</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">private</span> <span class="token class-name">FooService</span> fooService<span class="token punctuation">;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//使用方式上同，略</span></span>
<span class="line">  <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFooService</span><span class="token punctuation">(</span><span class="token class-name">FooService</span> fooService<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">this</span><span class="token punctuation">.</span>fooService <span class="token operator">=</span> fooService<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><h3 id="getbean" tabindex="-1"><a class="header-anchor" href="#getbean"><span>getbean</span></a></h3><p>其实还有一种方法,就是getbean 通过context获取bean,并可以在各个地方使用</p><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginContextHolder</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LoginContext</span> <span class="token function">me</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token class-name">SpringUtil</span><span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">LoginContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><h2 id="三、构造器注入的好处" tabindex="-1"><a class="header-anchor" href="#三、构造器注入的好处"><span>三、构造器注入的好处</span></a></h2><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as it enables one to implement application components as <em>immutable objects</em> and to ensure that required dependencies are not <code>null</code>. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state.</p></blockquote><p>咳咳，再来简单的翻译一下：这个构造器注入的方式啊，能够保证注入的<strong>组件不可变</strong>，并且确保需要的<strong>依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证<strong>完全初始化的状态</strong>。</p><p>下面来简单的解释一下：</p><ul><li>依赖不可变：其实说的就是final关键字，这里不再多解释了。不明白的园友可以回去看看Java语法。</li><li>依赖不为空（省去了我们对其检查）：当要实例化FooController的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK 。2：无该类型的参数-&gt;报错。所以保证不会为空，Spring总不至于传一个null进去吧 😦</li><li>完全初始化的状态：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法，这里不详细展开。）。所以返回来的都是初始化之后的状态。</li></ul><p>等等，比较完了setter注入与构造器注入的优缺点，你还没用说使用field注入与构造器的比较呢！那么我们再回头看一看使用最多的field注入方式：</p><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">//承接上面field注入的代码，假如客户端代码使用下面的调用(或者再Junit测试中使用)</span></span>
<span class="line"><span class="token comment">//这里只是模拟一下，正常来说我们只会暴露接口给客户端，不会暴露实现。</span></span>
<span class="line"><span class="token class-name">FooController</span> fooController <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FooController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">fooController<span class="token punctuation">.</span><span class="token function">listFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; NullPointerException</span></span>
<span class="line"></span></code></pre></div><p>如果使用field注入，缺点显而易见，<strong>对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，无法复用该实现类</strong>。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。</p><p>还值得一提另外一点是：使用field注入可能会导致循环依赖，即A里面注入B，B里面又注入A：</p><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre></div><p><strong>如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错</strong>。</p><h2 id="四、答疑" tabindex="-1"><a class="header-anchor" href="#四、答疑"><span>四、答疑</span></a></h2><p>好了，相信已经园友们知道了构造器注入的好处，那么回到了在前面提到的问题：</p><p><strong>Q1：跟3.x里说的一样，我要是有大量的依赖要注入，构造方法不会显得很臃肿吗？</strong></p><p>对于这个问题，说明你的类当中有太多的责任，那么你要好好想一想是不是自己违反了类的<strong>单一性职责原则</strong>，从而导致有这么多的依赖要注入。</p><p><strong>Q2：是不是其他的注入方式都不适合用了呢？</strong></p><p>当然不是，存在即是合理！setter的方式既然一开始被Spring推荐肯定是有它的道理，像之前提到的setter的方式能用让类在之后重新配置或者重新注入，就是其优点之一。除此之外，如果一个依赖有多种实现方式，我们可以使用<code>@Qualifier</code>，在构造方法里选择对应的名字注入，也可以使用field或者setter的方式来手动配置要注入的实现。</p><h2 id="五、总结" tabindex="-1"><a class="header-anchor" href="#五、总结"><span>五、总结</span></a></h2><p>使用构造器注入的好处：</p><ol><li>保证依赖不可变（final关键字）</li><li>保证依赖不为空（省去了我们对其检查）</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li><li>避免了循环依赖</li><li>提升了代码的可复用性</li></ol><p>另外，当有一个依赖有多个实现的使用，推荐使用field注入或者setter注入的方式来指定注入的类型。这是spring官方博客对<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/" target="_blank" rel="noopener noreferrer">setter注入方式和构造器注入的比较</a>。</p><h2 id="autowired和resource对比" tabindex="-1"><a class="header-anchor" href="#autowired和resource对比"><span>autowired和resource对比</span></a></h2><h2 id="差异" tabindex="-1"><a class="header-anchor" href="#差异"><span>差异</span></a></h2><ol><li><p>@Autowired和@Resource都可以用来装配bean，都可以写在字段上，或者方法上。</p></li><li><p>@Autowired属于Spring的；@Resource为JSR-250标准的注释，属于J2EE的。</p></li><li><p>@Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p></li></ol><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;baseDao&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">BaseDao</span> baseDao<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><ol start="4"><li>@Resource，默认安装名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</li></ol><p>例如：</p><div class="language-java" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">&quot;baseDao&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token class-name">BaseDao</span> baseDao<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</p></div>`,46)])])}const i=a(t,[["render",o]]),r=JSON.parse('{"path":"/java-tutor/springboot/tips/autowire-method.html","title":"注入方式","lang":"zh-CN","frontmatter":{"description":"注入方式 一、前言 Spring框架对Java开发的重要性不言而喻，其核心特性就是IOC（Inversion of Control， 控制反转）和AOP，平时使用最多的就是其中的IOC，我们通过将组件交由Spring的IOC容器管理，将对象的依赖关系由Spring控制，避免硬编码所造成的过度程序耦合。前几天的时候，笔者的同事问我为什么要使用构造器的注入...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"注入方式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-29T06:47:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yzqdev\\",\\"url\\":\\"http://www.yzqdev.top\\"}]}"],["meta",{"property":"og:url","content":"https://yzqdev.github.io/cs-guide/cs-guide/java-tutor/springboot/tips/autowire-method.html"}],["meta",{"property":"og:site_name","content":"cs-guide"}],["meta",{"property":"og:title","content":"注入方式"}],["meta",{"property":"og:description","content":"注入方式 一、前言 Spring框架对Java开发的重要性不言而喻，其核心特性就是IOC（Inversion of Control， 控制反转）和AOP，平时使用最多的就是其中的IOC，我们通过将组件交由Spring的IOC容器管理，将对象的依赖关系由Spring控制，避免硬编码所造成的过度程序耦合。前几天的时候，笔者的同事问我为什么要使用构造器的注入..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-29T06:47:23.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-29T06:47:23.000Z"}]]},"git":{"createdTime":1655535285000,"updatedTime":1711694843000,"contributors":[{"name":"yzqdev","username":"yzqdev","email":"yzqdev@outlook.com","commits":2,"url":"https://github.com/yzqdev"}]},"readingTime":{"minutes":6.77,"words":2030},"filePathRelative":"java-tutor/springboot/tips/autowire-method.md","autoDesc":true}');export{i as comp,r as data};
